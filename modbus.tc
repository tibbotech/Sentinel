#include "global.th"
#include "modbus.th"
#include "utils.th"


/*
 * ModBus RTU  
 * Baud Rate                19200
 * Incoming Flow Control    none
 * Outgoing Flow Control    none
 * Data Bits                8-bit
 * Stop Bits                1-bit
 * Parity                   none
 */ 

/* Packet receiver state
 */
static modbus_state _state;
static dword _timeout;
static string _packet; 	// data accumulation buffer
static byte _pdu_len;	// PDU length byte


extern void on_tibbo_sensor_discovery(string);


static byte _crc_table_hi[] = {
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
};


static byte _crc_table_lo[] = {
	0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,0x04,
	0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,0x08,0xC8,
	0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,
	0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,0x11,0xD1,0xD0,0x10,
	0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
	0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,0x3B,0xFB,0x39,0xF9,0xF8,0x38,
	0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,
	0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,
	0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,
	0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
	0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,
	0xB4,0x74,0x75,0xB5,0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,
	0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,
	0x9C,0x5C,0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,
	0x88,0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
	0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40,
};


/**
 * CRC generation function 
 */
word 
crc16(byte *data, byte byte_cnt)
{
    byte crc_hi = 0xFF;  
    byte crc_lo = 0xFF; 
    word idx; 
    
    while(byte_cnt--) { 
        idx = crc_hi ^ *data++; 
        crc_hi = crc_lo ^ _crc_table_hi[idx];
        crc_lo = _crc_table_lo[idx];
    }

	return (crc_hi << 8) | crc_lo;
}


#define MB_RQ_SIZE sizeof(modbus_req)


/*! \brief Issue ModBus request
 */
void
modbus_request(ioport *port, byte devaddr, byte request, word start, word count)
{
	string<MB_RQ_SIZE> data;
	modbus_req *t = (modbus_req *)&data[0];
	word *wcrc;
	
	data = strgen(MB_RQ_SIZE, "\0");
	
	t->addr = devaddr;
	t->hdr.func_code = request;
	t->hdr.address = htons(start);
	t->hdr.count = htons(count);
	t->crc = htons(crc16((byte *)t, sizeof(*t) - sizeof(t->crc)));
	
	_packet = "";
	_state = MODBUS_IDLE;
	_timeout = sys.timercountms + MODBUS_TIMEOUT;
	
#if 1
	DBG(hexdump((byte *)&data[0], len(data)));
#endif	

	serial_send(port, data);
}


/** [device_address] ([function_code] [data x N]) [checksum_hi][checksum_lo]
 */
static void
modbus_parse_adu_rtu(sensor *sens, string& packet)
{
	word *pw;
	float *pf;
	string<4> tmp;
	
	if(len(packet) < 5)
		return; // packet too small
		
	switch(packet[2]) {
		case sizeof(word):
			pw = (word *)&packet[3];
			sens->prev = sens->res;
			sens->res[0].type = TYPE_LONG;
			sens->res[0].l = (long)htons(*pw);
			break;

		case sizeof(float):
			pf = (float *)&tmp[0];
			
			/* Change byte order */
			tmp[0] = packet[6];
			tmp[1] = packet[5];
			tmp[2] = packet[4];
			tmp[3] = packet[3];
			
			sens->prev = sens->res;
			sens->res[0].type = TYPE_FLOAT;
			sens->res[0].f = *pf;
			break;
	}
	
#if 0	
	DBG(hexdump((byte *)&packet[0], len(packet)));
#endif	
}


static void
modbus_parse_adu_tcp(string& packet)
{
	/* -!- */
	/* Parses application data unit of ModBus packet */
	return;
}


/* This routine should be called either from on_sock_data_arrival() or 
 * on_ser_data_arrival() event handlers
 * Routine receives and parses ModBus PDU
 */
void
on_modbus_data_arrival(modbus_source src)
{
	string tmp;
	byte s1, s2, lp;
		
	if(MODBUS_TCP == src)
		tmp = sock.getdata(255);
	else
		tmp = ser.getdata(255);

	/* Now, check for possible full packet and extract it 
	 */
	switch(_state) {
		case MODBUS_FINISHED:
			ERR("Previous ModBus packet was not processed");
			break;
			
		case MODBUS_IDLE:
			_packet = "";
			_state = MODBUS_RECEIVING;
			/* fall through to the next case */
			
		case MODBUS_RECEIVING:
			_packet += tmp;
#if 1
			DBG(hexdump((byte *)&tmp[0], len(tmp)));
#endif
			break;
	}

chk_packet:
	lp = len(_packet);
	
	if(lp >= 2) {
		_pdu_len = _packet[2] + 5; // Byte count, including slave address, crc, byte length and function code
		if(lp >= _pdu_len) {
			_state = MODBUS_FINISHED;
			//DBG("state = FINISHED");
			
			tmp = left(_packet, _pdu_len);
			
			s1 = tmp[_pdu_len-4];
			s2 = tmp[_pdu_len-3];
			
			if(s1 == 0xAA && s2 == 0x55) {
				/* This is sensor detection packet, it must be processed separately
				 * and don't reach main sensor polling code
				 */
				_packet = mid(_packet, _pdu_len, 255);
				
				on_tibbo_sensor_discovery(tmp);

				goto chk_packet;
			}
		}
	}
}


void
modbus_init()
{
	_state = MODBUS_IDLE;
}


bool
modbus_process_result(sensor *sens)
{
	if(MODBUS_FINISHED == _state) {
		modbus_parse_adu_rtu(sens, left(_packet, _pdu_len));
		return true;
	}

	return false;
}


bool
modbus_timeout()
{
	return sys.timercountms > _timeout;
}


bool
modbus_finished()
{
	return _state == MODBUS_FINISHED;
}


string
modbus_result()
{
	return _packet;
}


string 
modbus_sync_request(ioport *port, byte devaddr, byte request, word start, word count)
{
	modbus_request(port, devaddr, request, start, count);

	while(_state != MODBUS_FINISHED) {
		if(sys.timercountms > _timeout)
			return "";
			
		doevents;
	}

	return _packet;
}
